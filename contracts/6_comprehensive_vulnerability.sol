// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract CommonVulnerability {
    // 直接用等号判断比较危险，ether也可以通过 selfdestruct 和 预先计算合约地址来强制发送
    function fund_reached() external view returns (bool) {
        return address(this).balance == 100 ether;
    }

    address private USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // 如果_from方给与此合约一定的allowance, 那调用者就可以将token转到自己的地址中
    function USDCTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) external {
        bool suc = IERC20(USDC).transferFrom(_from, _to, _amount);
        require(suc, "transfer must succeed");
    }

    // 任何人都可以调用自毁合约并接受以太
    function kill() external {
        selfdestruct(payable(msg.sender));
    }

    // delegatecall 非常危险，必须是可信任的合约地址，不能是用户随意传的
    function delegate(address _to, bytes memory _data) external {
        (bool suc, ) = _to.delegatecall(_data);
        require(suc);
    }

    mapping(address => uint256) public balances;

    // reentrancy 攻击，转账后才对余额进行扣减
    function withdraw(uint256 _amount) external {
        require(balances[msg.sender] >= _amount);
        (bool suc, ) = msg.sender.call{value: _amount}("");
        require(suc);
        balances[msg.sender] -= _amount;
    }

    uint256 public winningNumber;

    // 使用区块的hash、时间戳作为随机数都有被操纵的危险，可以使用 chainLink的 VRF
    function winLottery() external {
        winningNumber = uint256(block.timestamp) % 10;
    }

    uint256 amt;

    // 先做除法后做乘法是比较危险的操作(如果 b>a), 因为solidity中没有小数
    function divBeforeMul(
        uint256 a,
        uint256 b,
        uint256 c
    ) external {
        amt = (a / b) * c;
    }
}
