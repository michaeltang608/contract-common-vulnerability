// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

contract ContractRefBank {
    mapping(address => uint256) public balances;
    uint256 public minDeposit = 1 ether;
    ContractRefLog log;

    constructor(address _logAddr) payable {
        log = ContractRefLog(_logAddr);
        balances[msg.sender] = msg.value;
    }

    function deposit() external payable {
        require(msg.value >= minDeposit, "must exceed 1 ehter");
        balances[msg.sender] += msg.value;
        log.AddMsg(msg.sender, msg.value, "Deposit");
    }

    function withdraw(uint256 _amt) external {
        // 'unchecked' is used to demonstrate reentrant attack
        unchecked {
            require(
                _amt <= balances[msg.sender],
                "can not exceed your balance"
            );
            (bool suc, ) = msg.sender.call{value: _amt}("");
            require(suc, "withdraw fail");
        }

        log.AddMsg(msg.sender, _amt, "withdraw");
    }
}

contract ContractRefLog {
    struct Msg {
        address Sender;
        string Data;
        uint256 Value;
        uint256 Time;
    }

    Msg[] public history;
    Msg lastMsg;

    function AddMsg(
        address _sender,
        uint256 _value,
        string memory _data
    ) public {
        lastMsg.Sender = _sender;
        lastMsg.Data = _data;
        lastMsg.Value = _value;
        lastMsg.Time = block.timestamp;
        history.push(lastMsg);
    }
}

contract ContractRefLogFake {
    event Log(address, uint256, string);
    uint256 count;

    function AddMsg(
        address _sender,
        uint256 _value,
        string memory _data
    ) public {
        emit Log(_sender, _value, _data);
        require(
            keccak256(bytes(_data)) != keccak256("withdraw"),
            "withdraw forbidden"
        );
    }
}
